# 链表
## 21. 合并两个有序链表
### 方法一：递归
```JAVA
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```
![](https://pic.leetcode-cn.com/44791a290462582675ea3377dbac43fada52391fb6545f6f9947d6e33feb928c-%E5%B9%BB%E7%81%AF%E7%89%872.JPG)
l1指向的是其余节点merge后的结果，然后 return l1和他后面的东西，return至上一层
<br>
(return相当于公式中的=）
### 方法二：迭代
```JAVA
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //新链表，设定一个哨兵节点 prehead
        ListNode prehead = new ListNode(-1);
        //prev开始是指向prehead
        ListNode prev = prehead;
        while (l1 != null && l2 != null){
            if (l1.val <= l2.val){
                //新的链表的next为小的
                prev.next = l1;
                //改变l1的指针，往后移一位
                l1 = l1.next;
            }else{
                prev.next = l2;
                l2 = l2.next;
            }
            //新链表的指针往后移一位
            prev = prev.next;
        }
        //当有一个链表到最后为null了，prev只要指向剩下的那个链表
        //同时也处理了l1 or l2其中一个为null的情况
        if (l1 == null) prev.next = l2;
        if (l2 == null) prev.next = l1;
        //返回prehead后面的部分
        return prehead.next;
    }
}
```
### 总结
本题没有必要用递归，用迭代更加自然

## 82. 删除排序链表中的重复元素 II
### 双指针
```JAVA
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        //考虑null或只有一个元素的情况
        if (head == null || head.next == null) return head;
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode a = dummy;
        ListNode b = head.next;
        while (b != null){
            //注意比较的对象
            if (a.next.val != b.val) {
            a = a.next;
            b = b.next;
        } else {
            //注意顺序！！要先判断b != null，因为后面要b.val
            while (b != null && a.next.val == b.val){
                b = b.next;
            }
            a.next = b;
            //更新b的指针：while结束后b有可能指向null，此时，b.next会报错，所以要判断边界情况
            b = (b == null) ? null:b.next;
        }
        }
        return dummy.next;
    }
}
```
## 83. 删除排序链表中的重复元素
```JAVA
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode a = dummy;
        ListNode b = head.next;
        while (b != null){
            if (a.next.val != b.val) {
            a = a.next;
            b = b.next;
        } else {
            while (b != null && a.next.val == b.val){
                b = b.next;
            }
            //与上一题的唯一区别
            a = a.next;
            a.next = b;
            b = (b == null) ? null:b.next;
        }
        }
        return dummy.next;
    }
}
```
## 141. 环形链表
### 快慢指针：慢指针每次移动一个节点，快指针每次两个，如果存在环两个指针一定相遇
```JAVA
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;
        ListNode a = head;
        ListNode b = head;
        //注意边界条件，别忘了b != null
        while (a != null && b != null && b.next != null) {
            a = a.next;
            b = b.next.next;
            if (a == b){
                return true;
            }
        }
        return false; 
    }
}
```
## 142. 环形链表 II
### 快慢指针
* 与上一题比，还要找到环的入口
* **结论：从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是环形入口的节点**
* [推理过程](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-jian-hua-gong-shi-jia-2/)
```JAVA
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) return null;
        ListNode a = head;
        ListNode b = head;
        //注意边界条件，别忘了b != null
        while (a != null && b != null && b.next != null) {
            a = a.next;
            b = b.next.next;
            if (a == b){
                //头结点出发一个指针
                ListNode p1 = head;
                //相遇结点出发一个指针
                ListNode p2 = a;
                //两个指针相遇的地方就是环的入口
                while (p1 != p2){
                    p1 = p1.next;
                    p2 = p2.next;
                }
                return p1;
            }
        }
        return null;   
    }
}
```
