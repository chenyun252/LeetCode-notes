# 链表
## 21. 合并两个有序链表
### 方法一：递归
```JAVA
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```
![](https://pic.leetcode-cn.com/44791a290462582675ea3377dbac43fada52391fb6545f6f9947d6e33feb928c-%E5%B9%BB%E7%81%AF%E7%89%872.JPG)
l1指向的是其余节点merge后的结果，然后 return l1和他后面的东西，return至上一层
<br>
(return相当于公式中的=）
### 方法二：迭代
```JAVA
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //新链表，设定一个哨兵节点 prehead
        ListNode prehead = new ListNode(-1);
        //prev开始是指向prehead
        ListNode prev = prehead;
        while (l1 != null && l2 != null){
            if (l1.val <= l2.val){
                //新的链表的next为小的
                prev.next = l1;
                //改变l1的指针，往后移一位
                l1 = l1.next;
            }else{
                prev.next = l2;
                l2 = l2.next;
            }
            //新链表的指针往后移一位
            prev = prev.next;
        }
        //当有一个链表到最后为null了，prev只要指向剩下的那个链表
        //同时也处理了l1 or l2其中一个为null的情况
        if (l1 == null) prev.next = l2;
        if (l2 == null) prev.next = l1;
        //返回prehead后面的部分
        return prehead.next;
    }
}
```
### 总结
本题没有必要用递归，用迭代更加自然
