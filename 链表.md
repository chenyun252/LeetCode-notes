# 链表
## 21. 合并两个有序链表
### 方法一：递归
```JAVA
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```
![](https://pic.leetcode-cn.com/44791a290462582675ea3377dbac43fada52391fb6545f6f9947d6e33feb928c-%E5%B9%BB%E7%81%AF%E7%89%872.JPG)
l1指向的是其余节点merge后的结果，然后 return l1和他后面的东西，return至上一层
<br>
(return相当于公式中的=）
### 方法二：迭代
```JAVA
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //新链表，设定一个哨兵节点 prehead
        ListNode prehead = new ListNode(-1);
        //prev开始是指向prehead
        ListNode prev = prehead;
        while (l1 != null && l2 != null){
            if (l1.val <= l2.val){
                //新的链表的next为小的
                prev.next = l1;
                //改变l1的指针，往后移一位
                l1 = l1.next;
            }else{
                prev.next = l2;
                l2 = l2.next;
            }
            //新链表的指针往后移一位
            prev = prev.next;
        }
        //当有一个链表到最后为null了，prev只要指向剩下的那个链表
        //同时也处理了l1 or l2其中一个为null的情况
        if (l1 == null) prev.next = l2;
        if (l2 == null) prev.next = l1;
        //返回prehead后面的部分
        return prehead.next;
    }
}
```
### 总结
本题没有必要用递归，用迭代更加自然

## 82. 删除排序链表中的重复元素 II
### 双指针
```JAVA
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        //考虑null或只有一个元素的情况
        if (head == null || head.next == null) return head;
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode a = dummy;
        ListNode b = head.next;
        while (b != null){
            //注意比较的对象
            if (a.next.val != b.val) {
            a = a.next;
            b = b.next;
        } else {
            //注意顺序！！要先判断b != null，因为后面要b.val
            while (b != null && a.next.val == b.val){
                b = b.next;
            }
            a.next = b;
            //更新b的指针：while结束后b有可能指向null，此时，b.next会报错，所以要判断边界情况
            b = (b == null) ? null:b.next;
        }
        }
        return dummy.next;
    }
}
```
